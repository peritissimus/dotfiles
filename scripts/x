#!/opt/homebrew/bin/bash
# x - Natural language to shell command converter using Groq API or local MLX

set -euo pipefail

# Bootstrap bash-oo-framework
SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" && pwd)"
source "${BASH_OO_FRAMEWORK:-$SCRIPT_DIR/lib}/oo-bootstrap.sh"
import UI/Color

# Constants
VERSION="1.1.0"
DEFAULT_GROQ_MODEL="meta-llama/llama-4-scout-17b-16e-instruct"
DEFAULT_LOCAL_MODEL="mlx-community/Llama-3.2-3B-Instruct-4bit"
LOCAL_API_URL="http://localhost:8080/v1/chat/completions"
GROQ_API_URL="https://api.groq.com/openai/v1/chat/completions"
CONFIG_DIR="$HOME/.x"
CONFIG_FILE="$CONFIG_DIR/config"

# Create config directory if needed
mkdir -p "$CONFIG_DIR"

# Load saved config if exists
if [ -f "$CONFIG_FILE" ]; then
  source "$CONFIG_FILE"
fi

# Help message
show_help() {
  echo ""
  echo -e "$(UI.Color.Bold)Usage:$(UI.Color.Default) x [--local] [--verbose] <instruction>"
  echo "       x --version"
  echo "       x --help"
  echo ""
  echo -e "$(UI.Color.Cyan)Example:$(UI.Color.Default) x get all the git branches"
  echo ""
  echo -e "$(UI.Color.Bold)Options:$(UI.Color.Default)"
  echo "  --local      Use local MLX server (localhost:8080)"
  echo "  --verbose    Enable debug output"
  echo "  --version    Show version information"
  echo "  --help, -h   Show this help message"
  echo ""
  echo -e "$(UI.Color.Bold)Description:$(UI.Color.Default)"
  echo "  x converts natural language instructions into shell commands."
  echo "  Supports both Groq API and local MLX server."
  echo ""
  echo -e "$(UI.Color.Bold)Backends:$(UI.Color.Default)"
  echo "  $(UI.Color.Cyan)Local MLX:$(UI.Color.Default)"
  echo "    Use --local flag or set X_LOCAL=1"
  echo "    Start server: mlx_lm.server --model mlx-community/Llama-3.2-3B-Instruct-4bit"
  echo "    Set X_MODEL to override the local model."
  echo ""
  echo "  $(UI.Color.Cyan)Groq API:$(UI.Color.Default)"
  echo "    Set GROQ_API_KEY environment variable"
  echo "    Set GROQ_MODEL to override the default model."
  echo ""
  echo -e "$(UI.Color.Bold)Available Groq Models:$(UI.Color.Default)"
  echo "  - meta-llama/llama-4-scout-17b-16e-instruct (default, fastest)"
  echo "  - llama-3.3-70b-versatile (fast + capable)"
  echo "  - llama-3.1-8b-instant"
  echo "  - moonshotai/kimi-k2-instruct"
}

# Handle --help flag
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
  show_help
  exit 0
fi

# Handle --version flag
if [[ "${1:-}" == "--version" ]]; then
  echo "x version $VERSION"
  exit 0
fi

# Parse flags
DEBUG=0
USE_LOCAL="${X_LOCAL:-0}"

while [[ "${1:-}" == --* ]]; do
  case "${1:-}" in
    --verbose)
      DEBUG=1
      shift
      ;;
    --local)
      USE_LOCAL=1
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Determine backend and validate requirements
if [[ "$USE_LOCAL" == "1" ]]; then
  API_URL="$LOCAL_API_URL"
  MODEL="${X_MODEL:-${SAVED_LOCAL_MODEL:-$DEFAULT_LOCAL_MODEL}}"
  AUTH_HEADER=""

  # Check if local server is running
  if ! curl -s --connect-timeout 1 "http://localhost:8080/v1/models" >/dev/null 2>&1; then
    echo -e "$(UI.Color.Red)Error: Local MLX server not running$(UI.Color.Default)"
    echo "Start it with: mlx_lm.server --model $DEFAULT_LOCAL_MODEL"
    exit 1
  fi
else
  # Check for Groq API key
  if [ -z "${GROQ_API_KEY:-}" ]; then
    echo -e "$(UI.Color.Red)Error: GROQ_API_KEY not set$(UI.Color.Default)"
    echo "Set it with: export GROQ_API_KEY='your-api-key'"
    echo "Or use local MLX: x --local <instruction>"
    exit 1
  fi
  API_URL="$GROQ_API_URL"
  MODEL="${GROQ_MODEL:-${SAVED_GROQ_MODEL:-$DEFAULT_GROQ_MODEL}}"
  AUTH_HEADER="Authorization: Bearer ${GROQ_API_KEY}"
fi

# Check if instruction is provided
if [ $# -eq 0 ]; then
  echo -e "$(UI.Color.Yellow)Usage:$(UI.Color.Default) x [--local] [--verbose] <instruction>"
  echo ""
  echo "Run 'x --help' for more information."
  exit 1
fi

# Combine all arguments into instruction
INSTRUCTION="$*"

# Build system prompt based on OS
OS_NAME=$(uname -s)
if [[ "$OS_NAME" == "Darwin" ]]; then
  OS_HINTS="- macOS with BSD commands (NOT GNU/Linux)
- ps: use 'ps aux | sort -k 4 -nr | head' for memory sorting (NO --sort flag)
- Use pipe + sort instead of GNU long options
- Use pbcopy/pbpaste for clipboard, open instead of xdg-open"
else
  OS_HINTS="- This is Linux with GNU coreutils
- GNU-style long options are supported (--sort, --color, etc.)"
fi

TOOL_PREFS="Preferred tools and patterns:
- rg (ripgrep) for search: rg pattern, rg -i pattern, rg -g '*.ts' pattern
- fd for finding files: fd pattern, fd -e ts, fd -g '*service.ts'
- xh for HTTP: xh get URL, xh post URL key=value key:=123 (use := for numbers/booleans)
- jq for JSON: pipe to jq '.', jq -r '.field', jq '.array[]'
- ll/eza for listing (not ls)
- z for directory jumping
- pbcopy/pbpaste for clipboard"

SYSTEM_PROMPT="You are a shell command generator. Convert the user's natural language instruction into a shell command.

Platform:
$OS_HINTS

Tool preferences:
$TOOL_PREFS

Rules:
- Return ONLY the shell command, nothing else
- No explanations, no markdown formatting, no code block markers
- No backticks, no \`\`\`bash\`\`\`, no comments
- Just the raw executable command(s)
- Use pipes (|) and operators (&&, ||) as needed
- If multiple commands are needed, combine them with && or ;"

USER_PROMPT="pwd: $(pwd)
Task: ${INSTRUCTION}"

[[ $DEBUG -eq 1 ]] && echo -e "$(UI.Color.DarkGray)DEBUG: Backend: $([ "$USE_LOCAL" == "1" ] && echo "Local MLX" || echo "Groq API")$(UI.Color.Default)" >&2
[[ $DEBUG -eq 1 ]] && echo -e "$(UI.Color.DarkGray)DEBUG: Using model: $MODEL$(UI.Color.Default)" >&2
[[ $DEBUG -eq 1 ]] && echo -e "$(UI.Color.DarkGray)DEBUG: Instruction: $INSTRUCTION$(UI.Color.Default)" >&2

# Build JSON payload
JSON_PAYLOAD=$(jq -n \
  --arg model "$MODEL" \
  --arg system "$SYSTEM_PROMPT" \
  --arg user "$USER_PROMPT" \
  '{
        model: $model,
        messages: [
            {role: "system", content: $system},
            {role: "user", content: $user}
        ],
        temperature: 0,
        max_tokens: 200
    }')

[[ $DEBUG -eq 1 ]] && echo -e "$(UI.Color.DarkGray)DEBUG: Sending request to $API_URL$(UI.Color.Default)" >&2

# Make API request
if [[ -n "$AUTH_HEADER" ]]; then
  RESPONSE=$(curl -s -X POST "$API_URL" \
    -H "Content-Type: application/json" \
    -H "$AUTH_HEADER" \
    -d "$JSON_PAYLOAD")
else
  RESPONSE=$(curl -s -X POST "$API_URL" \
    -H "Content-Type: application/json" \
    -d "$JSON_PAYLOAD")
fi

[[ $DEBUG -eq 1 ]] && echo -e "$(UI.Color.DarkGray)DEBUG: Response: $RESPONSE$(UI.Color.Default)" >&2

# Check for errors
if echo "$RESPONSE" | grep -q '"error"'; then
  ERROR_MSG=$(echo "$RESPONSE" | jq -r '.error.message // .error // "Unknown error"')
  echo -e "$(UI.Color.Red)Error: $ERROR_MSG$(UI.Color.Default)"
  exit 1
fi

# Extract command from response
COMMAND=$(echo "$RESPONSE" | jq -r '.choices[0].message.content' 2>/dev/null)

if [ -z "$COMMAND" ] || [ "$COMMAND" = "null" ]; then
  echo -e "$(UI.Color.Red)Error: Failed to generate command$(UI.Color.Default)"
  echo "API Response: $RESPONSE"
  exit 1
fi

# Clean up command (remove any accidental markdown, special tokens, preserve quotes)
COMMAND=$(echo "$COMMAND" | sed 's/^```[a-z]*//g' | sed 's/```$//g' | sed 's/^`//g' | sed 's/`$//g' | sed 's/<|eot_id|>//g' | sed 's/<|end_of_text|>//g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

# Copy command to clipboard (best-effort)
command -v pbcopy >/dev/null 2>&1 && printf "%s" "$COMMAND" | pbcopy

# Save working model to config
if [[ "$USE_LOCAL" == "1" ]]; then
  echo "SAVED_LOCAL_MODEL=\"$MODEL\"" >"$CONFIG_FILE"
else
  echo "SAVED_GROQ_MODEL=\"$MODEL\"" >"$CONFIG_FILE"
fi

# Display command beautifully
echo -e "  $(UI.Color.Blue)│$(UI.Color.Yellow) $(UI.Color.Bold)$COMMAND$(UI.Color.Default)"
echo -ne "  $(UI.Color.Blue)└─$(UI.Color.Default) $(UI.Color.DarkGray)execute? [Y/n] $(UI.Color.Default)"
read -n 1 -r
echo ""

if [[ $REPLY =~ ^[Nn]$ ]]; then
  echo ""
  exit 0
else
  echo ""
  eval "$COMMAND"
fi
