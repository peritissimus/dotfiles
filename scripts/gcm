#!/opt/homebrew/bin/bash
# gcm - Git Commit Message Generator using LLM APIs
# Supports: Local MLX, Groq, OpenAI

set -euo pipefail

# Bootstrap bash-oo-framework
SCRIPT_DIR="$(cd "${BASH_SOURCE[0]%/*}" && pwd)"
source "${BASH_OO_FRAMEWORK:-$SCRIPT_DIR/lib}/oo-bootstrap.sh"
import UI/Color

#################
### CONSTANTS ###
#################

readonly VERSION="3.0.0"

# API URLs
LOCAL_API_URL="http://localhost:8080/v1/chat/completions"
GROQ_API_URL="https://api.groq.com/openai/v1/chat/completions"
OPENAI_API_URL="https://api.openai.com/v1/chat/completions"

# Default models
DEFAULT_LOCAL_MODEL="mlx-community/Llama-3.2-3B-Instruct-4bit"
DEFAULT_GROQ_MODEL="meta-llama/llama-4-scout-17b-16e-instruct"
DEFAULT_OPENAI_MODEL="gpt-4o-mini"

# Config
CONFIG_DIR="$HOME/.gcm"
CONFIG_FILE="$CONFIG_DIR/config"

# Create config directory if needed
mkdir -p "$CONFIG_DIR"

# Load saved config if exists
if [ -f "$CONFIG_FILE" ]; then
  source "$CONFIG_FILE"
fi

###############
### HELPERS ###
###############

log_info() {
  echo -e "$(UI.Color.Cyan)$1$(UI.Color.Default)"
}

log_success() {
  echo -e "$(UI.Color.Green)$1$(UI.Color.Default)"
}

log_error() {
  echo -e "$(UI.Color.Red)$1$(UI.Color.Default)"
}

log_debug() {
  echo -e "$(UI.Color.DarkGray)$1$(UI.Color.Default)"
}

print_usage() {
  echo ""
  echo -e "$(UI.Color.Bold)Usage:$(UI.Color.Default) gcm [options]"
  echo ""
  echo -e "$(UI.Color.Bold)Backend Options:$(UI.Color.Default)"
  echo "  --groq           Use Groq API (default, fastest)"
  echo "  --openai         Use OpenAI API"
  echo "  --local          Use local MLX server (localhost:8080)"
  echo ""
  echo -e "$(UI.Color.Bold)Other Options:$(UI.Color.Default)"
  echo "  -a, --auto       Auto-approve (commit without confirmation)"
  echo "  -p, --preview    Preview commit message without committing"
  echo "  -c, --context    Additional context for the commit"
  echo "  -m, --model      Override the model for selected backend"
  echo "  -v, --verbose    Enable debug output"
  echo "  -h, --help       Show this help message"
  echo "  --version        Show version"
  echo ""
  echo -e "$(UI.Color.Bold)Environment Variables:$(UI.Color.Default)"
  echo "  GCM_BACKEND      Default backend: local, groq, openai"
  echo "  GROQ_API_KEY     API key for Groq"
  echo "  OPENAI_API_KEY   API key for OpenAI"
  echo ""
  echo -e "$(UI.Color.Bold)Examples:$(UI.Color.Default)"
  echo "  gcm                              # Auto: Groq > OpenAI > local"
  echo "  gcm -a                           # Auto-approve commit"
  echo "  gcm -p                           # Preview only"
  echo "  gcm -c 'Part of auth refactor'   # With context"
}

# Get project structure (respecting .gitignore)
get_project_structure() {
  git ls-files 2>/dev/null |
    while IFS= read -r file; do
      dirname "$file"
    done |
    sort -u |
    while IFS= read -r dir; do
      if [[ "$dir" != "." ]]; then
        depth=$(echo "$dir" | tr -cd '/' | wc -c)
        padding=$(printf '%*s' $((depth * 2)) '')
        echo "${padding}├── ${dir##*/}"
      fi
    done
}

# Get primary language(s) of the project
get_project_languages() {
  git ls-files 2>/dev/null |
    while IFS= read -r file; do
      extension="${file##*.}"
      if [[ "$extension" != "$file" ]]; then
        echo "$extension"
      fi
    done |
    sort | uniq -c | sort -rn | head -5 |
    awk '{print $2}' | tr '\n' ',' | sed 's/,$//'
}

# Size threshold for ignoring data files (5KB)
LARGE_FILE_THRESHOLD=5120

# Get staged files
get_staged_files() {
  git diff --cached --name-only
}

# Get large data files to ignore (json, sql > threshold)
get_ignored_files() {
  git diff --cached --name-only | while IFS= read -r file; do
    if [[ "$file" =~ \.(json|sql)$ ]] && [[ -f "$file" ]]; then
      local size
      size=$(wc -c < "$file" 2>/dev/null | tr -d ' ')
      if [[ "$size" -gt "$LARGE_FILE_THRESHOLD" ]]; then
        echo "$file"
      fi
    fi
  done
}

# Get staged changes (excluding large json/sql files)
get_staged_changes() {
  local ignored
  ignored=$(get_ignored_files)

  if [[ -n "$ignored" ]]; then
    # Build exclusion args
    local exclude_args=()
    while IFS= read -r file; do
      exclude_args+=(":(exclude)$file")
    done <<< "$ignored"
    git diff --cached -- . "${exclude_args[@]}"
  else
    git diff --cached
  fi
}

# Get Nx project graph if available
get_nx_graph() {
  if [[ -f "nx.json" ]] && command -v nx &>/dev/null; then
    nx graph --file=project-graph.json >/dev/null 2>&1
    if [[ -f "project-graph.json" ]]; then
      jq '{
        nodes: (.graph.nodes | to_entries | map({name: .value.name, type: .value.type})),
        dependencies: (.graph.dependencies | to_entries | map({source: .key, targets: (.value | map(.target))}))
      }' project-graph.json 2>/dev/null
      rm -f project-graph.json
    fi
  fi
}

#############################
### API CALL              ###
#############################

call_llm_api() {
  local prompt="$1"
  local api_url="$2"
  local model="$3"
  local auth_header="$4"

  local json_payload
  json_payload=$(jq -n \
    --arg model "$model" \
    --arg prompt "$prompt" \
    '{
      model: $model,
      messages: [
        {role: "user", content: $prompt}
      ],
      temperature: 0.3,
      max_tokens: 500
    }')

  local response
  if [[ -n "$auth_header" ]]; then
    response=$(curl -s -X POST "$api_url" \
      -H "Content-Type: application/json" \
      -H "$auth_header" \
      -d "$json_payload")
  else
    response=$(curl -s -X POST "$api_url" \
      -H "Content-Type: application/json" \
      -d "$json_payload")
  fi

  # Check for errors
  if echo "$response" | grep -q '"error"'; then
    local error_msg
    error_msg=$(echo "$response" | jq -r '.error.message // .error // "Unknown error"')
    log_error "API Error: $error_msg"
    exit 1
  fi

  # Extract content
  echo "$response" | jq -r '.choices[0].message.content // empty'
}

#############################
### COMMIT MESSAGE PROMPT ###
#############################

generate_commit_message() {
  local files="$1"
  local diff="$2"
  local project_structure="$3"
  local project_languages="$4"
  local additional_context="$5"
  local api_url="$6"
  local model="$7"
  local auth_header="$8"

  # Add context section to prompt if provided
  local context_section=""
  if [[ -n "$additional_context" ]]; then
    context_section="Additional Context: $additional_context

"
  fi

  # Get Nx graph if available
  local nx_graph
  nx_graph=$(get_nx_graph 2>/dev/null || echo "")
  local nx_section=""
  if [[ -n "$nx_graph" ]]; then
    nx_section="Project Graph:
$nx_graph

"
  fi

  local prompt="You are a commit message generator. Output ONLY the commit message, nothing else.

Format: <type>(<scope>): <description>

Types: feat|fix|docs|style|refactor|perf|test|build|ci|chore
Scope: file or module name (optional)
Description: imperative, lowercase, no period, <72 chars

Add body only for breaking changes or complex multi-file changes.
${context_section}${nx_section}
Files: ${files}

\`\`\`diff
${diff}
\`\`\`"

  call_llm_api "$prompt" "$api_url" "$model" "$auth_header"
}

##############
### MAIN  ###
##############

main() {
  # Check if we're in a git repository
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    log_error "Not a git repository"
    exit 1
  fi

  local preview=false
  local auto_approve=false
  local context=""
  local model_override=""
  local debug=0
  local backend="${GCM_BACKEND:-auto}"

  # Parse command line arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --local)
        backend="local"
        shift
        ;;
      --groq)
        backend="groq"
        shift
        ;;
      --openai)
        backend="openai"
        shift
        ;;
      -p|--preview)
        preview=true
        shift
        ;;
      -a|--auto)
        auto_approve=true
        shift
        ;;
      -c|--context)
        if [[ -z "${2:-}" ]]; then
          log_error "--context requires an argument"
          exit 1
        fi
        context="$2"
        shift 2
        ;;
      -m|--model)
        if [[ -z "${2:-}" ]]; then
          log_error "--model requires an argument"
          exit 1
        fi
        model_override="$2"
        shift 2
        ;;
      -v|--verbose)
        debug=1
        shift
        ;;
      -h|--help)
        print_usage
        exit 0
        ;;
      --version)
        echo "gcm version $VERSION"
        exit 0
        ;;
      *)
        log_error "Unknown option: $1"
        print_usage
        exit 1
        ;;
    esac
  done

  # Auto-detect backend if not specified
  if [[ "$backend" == "auto" ]]; then
    if [[ -n "${GROQ_API_KEY:-}" ]]; then
      backend="groq"
    elif [[ -n "${OPENAI_API_KEY:-}" ]]; then
      backend="openai"
    elif curl -s --connect-timeout 1 "http://localhost:8080/v1/models" >/dev/null 2>&1; then
      backend="local"
    else
      log_error "No backend available"
      echo "Set GROQ_API_KEY, OPENAI_API_KEY, or start local MLX server"
      exit 1
    fi
  fi

  # Configure backend
  local api_url model auth_header=""
  case "$backend" in
    local)
      api_url="$LOCAL_API_URL"
      model="${model_override:-${SAVED_LOCAL_MODEL:-$DEFAULT_LOCAL_MODEL}}"
      if ! curl -s --connect-timeout 1 "http://localhost:8080/v1/models" >/dev/null 2>&1; then
        log_error "Local MLX server not running"
        echo "Start it with: mlx_lm.server --model $DEFAULT_LOCAL_MODEL"
        exit 1
      fi
      ;;
    groq)
      if [[ -z "${GROQ_API_KEY:-}" ]]; then
        log_error "GROQ_API_KEY not set"
        exit 1
      fi
      api_url="$GROQ_API_URL"
      model="${model_override:-${SAVED_GROQ_MODEL:-$DEFAULT_GROQ_MODEL}}"
      auth_header="Authorization: Bearer ${GROQ_API_KEY}"
      ;;
    openai)
      if [[ -z "${OPENAI_API_KEY:-}" ]]; then
        log_error "OPENAI_API_KEY not set"
        exit 1
      fi
      api_url="$OPENAI_API_URL"
      model="${model_override:-${SAVED_OPENAI_MODEL:-$DEFAULT_OPENAI_MODEL}}"
      auth_header="Authorization: Bearer ${OPENAI_API_KEY}"
      ;;
    *)
      log_error "Unknown backend: $backend"
      exit 1
      ;;
  esac

  [[ $debug -eq 1 ]] && log_debug "Backend: $backend, Model: $model"

  # Check for staged changes
  local staged_files
  staged_files=$(get_staged_files)
  if [[ -z "$staged_files" ]]; then
    log_error "No staged changes. Use 'git add' first."
    exit 1
  fi

  # Check for ignored large files
  local ignored_files
  ignored_files=$(get_ignored_files)
  [[ $debug -eq 1 ]] && [[ -n "$ignored_files" ]] && log_debug "Ignoring large files: $ignored_files"

  local staged_diff
  staged_diff=$(get_staged_changes)
  if [[ -z "$staged_diff" ]]; then
    log_error "No changes detected in staged files."
    exit 1
  fi

  [[ $debug -eq 1 ]] && log_debug "Staged files: $staged_files"

  local project_structure project_languages
  project_structure=$(get_project_structure)
  project_languages=$(get_project_languages)

  [[ $debug -eq 1 ]] && log_debug "Languages: $project_languages"

  local commit_message
  commit_message=$(generate_commit_message \
    "$staged_files" \
    "$staged_diff" \
    "$project_structure" \
    "$project_languages" \
    "$context" \
    "$api_url" \
    "$model" \
    "$auth_header")

  # Clean up response: remove markdown, preamble, quotes
  commit_message=$(echo "$commit_message" | \
    sed 's/^```[a-z]*//g' | \
    sed 's/```$//g' | \
    sed 's/^`//g' | \
    sed 's/`$//g' | \
    sed '/^[Hh]ere is/d' | \
    sed '/^[Tt]his is/d' | \
    sed '/^[Bb]ased on/d' | \
    sed '/^I have/d' | \
    sed '/^$/d' | \
    sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

  if [[ -z "$commit_message" ]]; then
    log_error "Failed to generate commit message"
    exit 1
  fi

  # Save working model to config
  case "$backend" in
    local)  echo "SAVED_LOCAL_MODEL=\"$model\"" > "$CONFIG_FILE" ;;
    groq)   echo "SAVED_GROQ_MODEL=\"$model\"" > "$CONFIG_FILE" ;;
    openai) echo "SAVED_OPENAI_MODEL=\"$model\"" > "$CONFIG_FILE" ;;
  esac

  # Copy to clipboard
  command -v pbcopy >/dev/null 2>&1 && printf "%s" "$commit_message" | pbcopy

  # Display commit message with box drawing
  local first_line rest_lines
  first_line=$(echo "$commit_message" | head -n1)
  rest_lines=$(echo "$commit_message" | tail -n +2)

  echo -e "  $(UI.Color.Blue)│$(UI.Color.Default) $(UI.Color.Yellow)$(UI.Color.Bold)$first_line$(UI.Color.Default)"
  if [[ -n "$rest_lines" ]]; then
    echo "$rest_lines" | while IFS= read -r line; do
      echo -e "  $(UI.Color.Blue)│$(UI.Color.Default) $(UI.Color.DarkGray)$line$(UI.Color.Default)"
    done
  fi

  if [[ "$preview" == true ]]; then
    echo -e "  $(UI.Color.Blue)└─$(UI.Color.Default) $(UI.Color.DarkGray)copied to clipboard$(UI.Color.Default)"
  elif [[ "$auto_approve" == true ]]; then
    echo -e "  $(UI.Color.Blue)└─$(UI.Color.Default) $(UI.Color.DarkGray)committing...$(UI.Color.Default)"
    git commit -m "$commit_message" -n
  else
    echo -ne "  $(UI.Color.Blue)└─$(UI.Color.Default) $(UI.Color.DarkGray)commit? [Y/n] $(UI.Color.Default)"
    read -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Nn]$ ]]; then
      exit 0
    else
      git commit -m "$commit_message" -n
    fi
  fi
}

# Run the script
main "$@"
